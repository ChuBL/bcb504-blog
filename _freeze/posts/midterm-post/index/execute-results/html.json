{
  "hash": "d2bed609fa6a96f8935933371cd6d65b",
  "result": {
    "markdown": "---\ntitle: \"From Midterms to Championships: Hopw to Build Winning Pokémon Teams\"\nauthor: \"Jiyin Zhang\"\nsubtitle: \"Insightful Visualizations of Pokémon Showdown Battle Data\"\ndate: \"2023-03-30\"\ncategories: [Assignment, DataViz, Smogon, Pokémon Showdown]\nimage: image_j28MHAY0_1680213973861_raw.jpeg\ncode-fold: true\ncode-tools: true\ndescription: \"Zapping Through the 10,000,000 Pokémon Battles\"\nformat: html\n---\n\n# PREAMBLE\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(igraph)\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(gridExtra)\nlibrary(jsonlite)\n```\n:::\n\n\n<p style=\"color:red\">POKEMONS.</p>\n\n[Smogon](https://www.smogon.com/) is a popular online community of competitive Pokémon players that was founded in 2004. The community focuses on the competitive side of Pokémon battling, providing resources such as guides, forums, and a tier system that classifies Pokémon based on their power level. Smogon's tier system is used by many competitive players to build their teams and strategies. The community also hosts tournaments and events for players to compete in.\n\n[Pokemon Showdown](https://pokemonshowdown.com/) is an online battle simulator created by Smogon that allows players to build and battle with Pokémon teams in a virtual environment. It is widely used by the competitive Pokémon community and is an important tool for testing and refining strategies. Players can customize their teams with specific moves, items, and abilities, and then battle against other players in real-time.\n\nThe objective of this study is to develop effective visualizations for the comprehensive datasets available in the Smogon databases. The aim is to present the Pokemon battle data in a clear and intuitive manner using visual plots. Through the use of such visualizations, I aim to provide valuable insights and suggestions to users on how to build a successful Pokemon battle team. Our approach seeks to enhance the user's understanding of the data by presenting it in a visually engaging format, thereby enabling them to make informed decisions when building their team. The ultimate goal is to offer an optimized user experience that facilitates an improved decision-making process and increases the success rate of the user's Pokemon battle team.\n\n\n\n\n# Data Preparation\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\nimport requests\nfrom lxml import html\nfrom pathlib import Path\nimport sys\n\nurl = \"https://www.smogon.com/stats/\"\ndata_dir = os.path.join(os.getcwd(), \"data\")\n\ndef download_files(url, dir_path=data_dir):\n    # use pathlib to create the directory whether the parent directory exists or not\n    Path(dir_path).mkdir(parents=True, exist_ok=True)\n\n    response = requests.get(url)\n    parsed_body = html.fromstring(response.content)\n\n    for index in range(1, 65535):\n        try:\n            link = parsed_body.xpath(\"/html/body/pre/a[{index}]\".format(index=index))[0]\n        except IndexError:\n            break\n        text = link.text\n        if \"..\" in text:\n            continue\n        if \".\" in text:\n            file_url = url + text\n            file_path = os.path.join(dir_path, file_url.split(\"/\")[-1])\n            print(\"Downloading\", file_url)\n            r = requests.get(file_url)\n            with open(file_path, \"wb\") as f:\n                f.write(r.content)\n            print(\"Downloaded\", file_url)\n            #sys.exit()\n        else:\n            new_url = url + text\n            new_dir = os.path.join(dir_path, text)\n            download_files(new_url, new_dir)\n\n\ndef batch_download_by_year(YEAR):\n    response = requests.get(url)\n    parsed_body = html.fromstring(response.content)\n    for index in range(1, 65535):\n        try:\n            link = parsed_body.xpath(\"/html/body/pre/a[{index}]\".format(index=index))[0]\n        except IndexError:\n            break\n        text = link.text\n        if str(YEAR) in text:\n            print(\"Downloading\", YEAR)\n            new_url = url + text\n            new_dir = os.path.join(data_dir, str(YEAR), text)\n            download_files(new_url, new_dir)\n\n    year_url = url + str(YEAR) + \"/\"\n    year_dir = os.path.join(data_dir, str(YEAR))\n    download_files(year_url, year_dir)\n\n\ndef _test_parse():\n    response = requests.get(url)\n    parsed_body = html.fromstring(response.content)\n    link = parsed_body.xpath(\"/html/body/pre/a[999]\")[0]\n    #text = link.text\n    #print(text)\n\nif __name__ == \"__main__\":\n    batch_download_by_year(2023)\n```\n:::\n\n\n> I managed to grab a huge bunch of data from the Smogon forum since it is hard to collect similar Pokemon battle data from official websites, except for some crazy poke fans who can manually recognize and record the Pokemon ranking information and player teams from the official competition videos.\nThe collected data can be accessed from this [source](https://www.smogon.com/stats/). My local data collection is managed accordingly to the file hierarchy of this straightforward website.\nMy current work focuses on the data recorded in 2023. The Pokemon battle data are stored in `.txt` and `.json` formats. I am working on reading some forum threads about the data discussion and explanations. The next plan is to convert the interesting part of the data into an R data frame and end up with visualizations.\n\n<!-- I am unfamiliar with some Pokemon names and skills in English, which inevitably lowers my efficiency in parsing the data. At the same time, the good news is the dataset size is overwhelming, which means I don't have to bother particular Pokemons but the whole tendency patterns. -->\n\nI applied the dataset called `gen9vgc2023series2-1630` for this pokemon battle research. \n\n**gen9** stands for the 9th generation of pokemon of Scarlet & Violet. The games will feature a brand new open-world region, three original starters, and new Legendaries for players to discover. \n\n**vgc2023** stands for the Pokemon VGC (Video Game Championships) rules in 2023. The rules can vary slightly from year to year, but generally, the VGC format is a double battle format where each player brings a team of six Pokemon and chooses four of them to use in each battle. Players can only use Pokemon from the current generation of games, and there are restrictions on which Pokemon are allowed based on their species, level, and items. \n\n**series2** refers to detailed battle rules. This series allows trainers to use a team of 3-6 Pokémon (for Singles) or 4-6 Pokémon (for Doubles) from Level 1 to Level 100, with all Pokémon then set to Level 50. There are more details omitted here.\n\n**1630** stands for a specific battle tiers for a fan-made rules.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Read the CSV files\npokemon_data <- read_csv(\"gen9vgc2023series2-1630.csv\")\npokemon_data$`Usage%` <- as.numeric(gsub(\"%\", \"\", pokemon_data$`Usage%`))\nedge_data <- read_csv(\"teammates.csv\")\n\n# Filter the top 50 Pokemon\ntop_20_pokemon <- head(pokemon_data, 20)\n```\n:::\n\n\n<figure style=\"text-align:center\">\n<img src=\"0987Flutter_Mane.png\" alt=\"Flutter Mane\" width=\"400\"/>\n<figcaption>Flutter Mane</figcaption>\n</figure>\n> The most popular pokemon till Feb, 2023: Flutter Mane.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_20_pokemon\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 7\n    Rank Pokemon      `Usage%`     Raw `Raw%`    Real `Real%`\n   <dbl> <chr>           <dbl>   <dbl> <chr>    <dbl> <chr>  \n 1     1 Flutter Mane     54.6 1454951 38.720% 729736 42.412%\n 2     2 Iron Bundle      40.8 1165153 31.007% 561782 32.651%\n 3     3 Iron Hands       32.4 1145260 30.478% 617069 35.864%\n 4     4 Great Tusk       27.8  673071 17.912% 364773 21.201%\n 5     5 Amoonguss        26.3  983437 26.172% 371485 21.591%\n 6     6 Arcanine         24.3  930540 24.764% 433178 25.176%\n 7     7 Gholdengo        22.0  663711 17.663% 299077 17.382%\n 8     8 Roaring Moon     18.5  642275 17.092% 268052 15.579%\n 9     9 Kingambit        17.4  556369 14.806% 238494 13.861%\n10    10 Dragonite        17.0  396729 10.558% 160427 9.324% \n11    11 Dondozo          16.2  315148 8.387%  166119 9.655% \n12    12 Armarouge        15.9  524411 13.956% 262358 15.248%\n13    13 Indeedee-F       15.8  532736 14.177% 235561 13.691%\n14    14 Tatsugiri        15.8  313274 8.337%  176483 10.257%\n15    15 Maushold         15.8  452690 12.047% 186586 10.844%\n16    16 Talonflame       15.6  476666 12.685% 138081 8.025% \n17    17 Brute Bonnet     14.0  374798 9.974%  156833 9.115% \n18    18 Tyranitar        12.3  314751 8.376%  149872 8.711% \n19    19 Annihilape       12.2  514816 13.700% 252072 14.650%\n20    20 Palafin          11.9  416057 11.072% 235410 13.682%\n```\n:::\n:::\n\n<!-- gen9vgc2023series2-1630 -->\n<!--  Total battles: 1878825 -->\n<!--  Avg. weight/team: 0.021 -->\n\nThe given data frame provides information on the top used Pokemon in the Smogon database, along with their usage percentages, weighted and unweighted raw counts, and \"real\" counts. The \"real\" count refers only to the Pokemon that actually appear in battle, as opposed to counting all six Pokemon in a team. The data frame provides valuable insights into the popularity of different Pokemon in the Smogon community and can be used to inform strategic decisions regarding team building and battling.\n\n# Visualizations\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntop20_pokemon_list <- pokemon_data$Pokemon[1:20]\nedge_data <- subset(edge_data, from %in% top20_pokemon_list & to %in% top20_pokemon_list)\n# Create a graph from the edge data\ng <- graph_from_data_frame(edge_data, directed = FALSE)\n\n# Set vertex attributes: size and labels\nV(g)$size <- top_20_pokemon$`Usage%`\nV(g)$label <- top_20_pokemon$Pokemon\n\n# Set edge attributes: width\nE(g)$width <- as.numeric(substr(edge_data$weight, 1, nchar(edge_data$weight) - 1)) / 100\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the graph\nlayout <- layout_nicely(g)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in (function (graph, coords = NULL, dim = 2, niter = 500, start.temp =\nsqrt(vcount(graph)), : NAs introduced by coercion\n```\n:::\n\n```{.r .cell-code}\nsuppressWarnings({\nplot(g,\n     vertex.label.cex = 0.8, # Adjust the font size of vertex labels\n     vertex.label.family = \"sans\",\n     vertex.label.color = \"black\",\n     vertex.frame.color = \"black\",\n     vertex.color = \"lightblue\",\n     edge.arrow.size = 0,\n     edge.color = \"gray\",\n     #layout = layout_with_fr(g, niter = 2000) # Set the layout algorithm\n     layout = layout,\n     #vertex.label.dist = 5, # Increase the distance of the label from the vertex\n     #vertex.label.degree = 45 \n     )\ntitle(main = \"The top 20 Pokemon and their teammates\")\n})\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/my-plot-1.png){width=10in height=8in}\n:::\n:::\n\n\nThese codes aim to create a network visualization of the top 20 Pokemon and their teammates in the gen9 VGC 2023 series 2 using the R package igraph. The code reads in two CSV files, \"gen9vgc2023series2-1630.csv\" and \"teammates.csv\", which contain the data on the Pokemon and their teammates.\n\nThe graph is plotted with various visualization settings, such as adjusting the font size of vertex labels, setting the layout algorithm to `layout_nicely()`, and suppressing any warning messages that may arise during the plotting process. The resulting graph represents the top 20 Pokemon and their teammates as nodes and edges, respectively, with the size of each node representing its usage percentage.\n\nThe `layout_nicely()` isn't a satisfying solution to such not even complex network. The static network appeared to be insufficient when the number of nodes and links increase.\n\n::: callout-note\nIt occurred to me that it is hard to increase the node distances.\nI have tried to apply the les miserable interactive network, but the code to the right side of `d3=` seems extremely long and very inconvenient to copy from the [website]( https://observablehq.com/@hepplerj/les-miserables-network). I would like to know that if I am getting anything wrong.\n:::\n\n\n```{ojs}\ngraph1 = ({\n  nodes: [\n    {id: \"a\"},\n    {id: \"b\"},\n    {id: \"c\"}\n  ],\n  links: []\n})\n\n\ngraph2 = ({\n  nodes: [\n    {id: \"a\"},\n    {id: \"b\"},\n    {id: \"c\"}\n  ],\n  links: [\n    {source: \"a\", target: \"b\"},\n    {source: \"b\", target: \"c\"},\n    {source: \"c\", target: \"a\"}\n  ]\n})\n\n\ngraph3 = ({\n  nodes: [\n    {id: \"a\"},\n    {id: \"b\"}\n  ],\n  links: [\n    {source: \"a\", target: \"b\"}\n  ]\n})\n\n\ncolor = d3.scaleOrdinal(d3.schemeTableau10)\n\nheight = 400\n```\n\n```{ojs}\nchart = ForceGraph(miserables, {\n  nodeId: d => d.id,\n  nodeGroup: d => d.group,\n  nodeTitle: d => `${d.id}\\n${d.group}`,\n  linkStrokeWidth: l => Math.sqrt(l.value),\n  width,\n  height: 600,\n  invalidation // a promise to stop the simulation when the cell is re-run\n})\n```\n\n```{ojs}\nmiserables = FileAttachment(\"output.json\").json()\n\n\n// Copyright 2021 Observable, Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/force-directed-graph\nfunction ForceGraph({\n  nodes, // an iterable of node objects (typically [{id}, …])\n  links // an iterable of link objects (typically [{source, target}, …])\n}, {\n  nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)\n  nodeGroup, // given d in nodes, returns an (ordinal) value for color\n  nodeGroups, // an array of ordinal values representing the node groups\n  nodeTitle, // given d in nodes, a title string\n  nodeFill = \"currentColor\", // node stroke fill (if not using a group color encoding)\n  nodeStroke = \"#fff\", // node stroke color\n  nodeStrokeWidth = 1.5, // node stroke width, in pixels\n  nodeStrokeOpacity = 1, // node stroke opacity\n  nodeRadius = 5, // node radius, in pixels\n  nodeStrength,\n  linkSource = ({source}) => source, // given d in links, returns a node identifier string\n  linkTarget = ({target}) => target, // given d in links, returns a node identifier string\n  linkStroke = \"#999\", // link stroke color\n  linkStrokeOpacity = 0.6, // link stroke opacity\n  linkStrokeWidth = 1.5, // given d in links, returns a stroke width in pixels\n  linkStrokeLinecap = \"round\", // link stroke linecap\n  linkStrength,\n  colors = d3.schemeTableau10, // an array of color strings, for the node groups\n  width = 640, // outer width, in pixels\n  height = 400, // outer height, in pixels\n  invalidation // when this promise resolves, stop the simulation\n} = {}) {\n  // Compute values.\n  const N = d3.map(nodes, nodeId).map(intern);\n  const LS = d3.map(links, linkSource).map(intern);\n  const LT = d3.map(links, linkTarget).map(intern);\n  if (nodeTitle === undefined) nodeTitle = (_, i) => N[i];\n  const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);\n  const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);\n  const W = typeof linkStrokeWidth !== \"function\" ? null : d3.map(links, linkStrokeWidth);\n  const L = typeof linkStroke !== \"function\" ? null : d3.map(links, linkStroke);\n\n  // Replace the input nodes and links with mutable objects for the simulation.\n  nodes = d3.map(nodes, (_, i) => ({id: N[i]}));\n  links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i]}));\n\n  // Compute default domains.\n  if (G && nodeGroups === undefined) nodeGroups = d3.sort(G);\n\n  // Construct the scales.\n  const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);\n\n  // Construct the forces.\n  const forceNode = d3.forceManyBody();\n  const forceLink = d3.forceLink(links).id(({index: i}) => N[i]);\n  if (nodeStrength !== undefined) forceNode.strength(nodeStrength);\n  if (linkStrength !== undefined) forceLink.strength(linkStrength);\n\n  const simulation = d3.forceSimulation(nodes)\n      .force(\"link\", forceLink)\n      .force(\"charge\", forceNode)\n      .force(\"center\",  d3.forceCenter())\n      .on(\"tick\", ticked);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  const link = svg.append(\"g\")\n      .attr(\"stroke\", typeof linkStroke !== \"function\" ? linkStroke : null)\n      .attr(\"stroke-opacity\", linkStrokeOpacity)\n      .attr(\"stroke-width\", typeof linkStrokeWidth !== \"function\" ? linkStrokeWidth : null)\n      .attr(\"stroke-linecap\", linkStrokeLinecap)\n    .selectAll(\"line\")\n    .data(links)\n    .join(\"line\");\n\n  const node = svg.append(\"g\")\n      .attr(\"fill\", nodeFill)\n      .attr(\"stroke\", nodeStroke)\n      .attr(\"stroke-opacity\", nodeStrokeOpacity)\n      .attr(\"stroke-width\", nodeStrokeWidth)\n    .selectAll(\"circle\")\n    .data(nodes)\n    .join(\"circle\")\n      .attr(\"r\", nodeRadius)\n      .call(drag(simulation));\n\n  if (W) link.attr(\"stroke-width\", ({index: i}) => W[i]);\n  if (L) link.attr(\"stroke\", ({index: i}) => L[i]);\n  if (G) node.attr(\"fill\", ({index: i}) => color(G[i]));\n  if (T) node.append(\"title\").text(({index: i}) => T[i]);\n  if (invalidation != null) invalidation.then(() => simulation.stop());\n\n  function intern(value) {\n    return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n  }\n\n  function ticked() {\n    link\n      .attr(\"x1\", d => d.source.x)\n      .attr(\"y1\", d => d.source.y)\n      .attr(\"x2\", d => d.target.x)\n      .attr(\"y2\", d => d.target.y);\n\n    node\n      .attr(\"cx\", d => d.x)\n      .attr(\"cy\", d => d.y);\n  }\n\n  function drag(simulation) {    \n    function dragstarted(event) {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      event.subject.fx = event.subject.x;\n      event.subject.fy = event.subject.y;\n    }\n    \n    function dragged(event) {\n      event.subject.fx = event.x;\n      event.subject.fy = event.y;\n    }\n    \n    function dragended(event) {\n      if (!event.active) simulation.alphaTarget(0);\n      event.subject.fx = null;\n      event.subject.fy = null;\n    }\n    \n    return d3.drag()\n      .on(\"start\", dragstarted)\n      .on(\"drag\", dragged)\n      .on(\"end\", dragended);\n  }\n\n  return Object.assign(svg.node(), {scales: {color}});\n}\n\n\nimport {howto} from \"@d3/example-components\"\n\nimport {Swatches} from \"@d3/color-legend\"\n\n```\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame with the usage percentages for each teammate\nteammates <- data.frame(\n  Name = c(\"Iron Bundle\", \"Great Tusk\", \"Iron Hands\", \"Arcanine\", \"Amoonguss\", \"Kingambit\", \"Dondozo\", \"Dragonite\", \"Talonflame\", \"Tatsugiri\", \"Roaring Moon\"),\n  Usage = c(37.840, 29.509, 27.440, 23.847, 23.497, 19.474, 17.338, 17.326, 16.669, 16.646, 14.669)\n)\n\n# Reorder the factor levels of the Name variable based on the Usage variable\nteammates$Name <- factor(teammates$Name, levels = teammates$Name[order(desc(teammates$Usage))])\n\n# Create a bar plot\nggplot(data = teammates, aes(x = Name, y = Usage)) +\n  geom_bar(stat = \"identity\") +\n  xlab(\"Teammate Name\") +\n  ylab(\"Usage Percentage\") +\n  ggtitle(\"Usage Percentages of Teammates for Flutter Mane\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nUsage Percentages of Teammates for **Flutter Mane**, ordered by the usage percentages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame with the names and weights of the teammates\nteammates <- data.frame(\n  from = rep(\"Flutter Mane\", times = 11),\n  to = c(\"Iron Bundle\", \"Great Tusk\", \"Iron Hands\", \"Arcanine\", \"Amoonguss\", \"Kingambit\", \"Dondozo\", \"Dragonite\", \"Talonflame\", \"Tatsugiri\", \"Roaring Moon\"),\n  weight = c(37.840, 29.509, 27.440, 23.847, 23.497, 19.474, 17.338, 17.326, 16.669, 16.646, 14.669)\n)\n\n# Create a graph object\ng <- graph_from_data_frame(teammates, directed = TRUE)\n\n# Set the vertex attributes\nV(g)$label <- V(g)$name\nV(g)$size <- 20\n\n# Set the edge attributes\nE(g)$width <- 1/100 * E(g)$weight\n\n# set size of nodes based on Usage% from top_20_pokemon\nsize <- top_20_pokemon$`Usage%`/1000\n\n# color nodes based on Usage%\ncols <- colorRampPalette(c(\"blue\", \"red\"))(length(size))\ncols <- cols[rank(rank(size))]\n\n# # Add the size legend\n# legend(\"bottomright\", \n#        legend = c(\"Usage%\"),\n#        cex = 0.8,\n#        pt.cex = 2,\n#        pt.bg = \"white\",\n#        pch = 21,\n#        pt.col = \"black\",\n#        bty = \"n\",\n#        title = \"Node Size\")\n# \n# # Add the color legend\n# legend(\"bottomleft\", \n#        legend = c(\"Low Usage\", \"High Usage\"),\n#        fill = colorRampPalette(c(\"blue\", \"red\"))(10),\n#        bty = \"n\",\n#        title = \"Node Color\")\n\n\n# Plot the graph with captions and legends\nplot(g, vertex.label.color = \"black\", vertex.color = cols, edge.color = \"gray\",\n     main = \"Pokemon Teammates Network for Flutter Mane\",\n     sub = \"Channel: Length, Marks: Lines\",\n     # vertex.size.legend = list(title = \"Usage%\", labels = c(\"Low\", \"High\")),\n     # vertex.color.legend = list(title = \"Usage%\", at = seq(0, 1, length.out = length(cols)), labels = NULL),\n     # edge.width.legend = list(title = \"Weight\", at = seq(0, 1, length.out = 5), labels = NULL)\n     )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nThis code creates a network visualization of the top 20 ranked Pokémon and their teammates for the Pokémon named \"Flutter Mane\". The visualization shows the connections between the Pokémon and their teammates. Center node represents a Pokémon and others are teammates, and the size of the node is proportional to the Usage% of that Pokémon in battles. The color of the node represents the Usage% of the Pokémon, with blue representing low usage and red representing high usage.\n\nThis visualization is useful for understanding the relationships between the top-ranked Pokémon and their teammates, and can provide insights for building a strong Pokémon battle team. It can also help identify patterns in the data that may be difficult to see in a table or spreadsheet format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the necessary libraries\n\n\n# create a sample data frame of items and their frequencies\nitems <- data.frame(\n  Item = c(\"Focus Sash\", \"Choice Specs\", \"Life Orb\", \"Booster Energy\", \"Other\"),\n  Freq = c(32.151, 26.383, 24.673, 13.824, 2.969)\n)\n\n# # create a bar chart of the item frequencies\n# bar_chart <- ggplot(items, aes(x = Item, y = Freq, fill = Item)) +\n#   geom_bar(stat = \"identity\") +\n#   ggtitle(\"Item Frequencies\") +\n#   xlab(\"Item\") +\n#   ylab(\"Frequency (%)\") +\n#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n# \n# # create a sorted bar chart of the item frequencies\n# sorted_bar_chart <- items %>%\n#   arrange(desc(Freq)) %>%\n#   ggplot(aes(x = Item, y = Freq, fill = Item)) +\n#   geom_bar(stat = \"identity\") +\n#   ggtitle(\"Item Frequencies (sorted)\") +\n#   xlab(\"Item\") +\n#   ylab(\"Frequency (%)\") +\n#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n# create a stacked bar chart of the item frequencies by category\ncategories <- c(rep(\"Common\", 3), rep(\"Uncommon\", 1), \"Rare\")\nitem_categories <- data.frame(Item = items$Item, Category = categories, Freq = items$Freq)\nstacked_bar_chart <- ggplot(item_categories, aes(x = Category, y = Freq, fill = Item)) +\n  geom_bar(stat = \"identity\") +\n  ggtitle(\"Item Frequencies by for Flutter Mane\") +\n  xlab(\"Category\") +\n  ylab(\"Frequency (%)\") +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\nstacked_bar_chart\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# create a grid of the plots\n#grid.arrange(bar_chart, sorted_bar_chart, stacked_bar_chart, ncol = 2)\n```\n:::\n\n\nThis code creates a stacked bar chart of the item frequencies for the Pokemon \"Flutter Mane\". The code first creates a sample data frame called \"items\" with the columns \"Item\" and \"Freq\" to represent the name of each item and its frequency. The next step involves creating a new data frame called \"item_categories\" which adds a third column called \"Category\" to the \"items\" data frame. The \"Category\" column is a factor variable that categorizes each item as \"Common\", \"Uncommon\", or \"Rare\".\n\nThe code then uses the ggplot2 library to create a stacked bar chart, with the \"Category\" variable on the x-axis, the \"Freq\" variable on the y-axis, and each \"Item\" represented by a different color within each category. The resulting plot shows the relative frequency of each item in each category.\n\nThe code also contains commented-out code that creates two additional bar charts: a basic bar chart of the item frequencies and a sorted bar chart of the item frequencies. These were likely created as exploratory plots before settling on the final stacked bar chart. Finally, the code also includes commented-out code for creating a grid of the plots, but this is not used in the final output.\n\n# Failed Attempts\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the necessary libraries\n\n\n# read in the data from the json file\ndata <- fromJSON(\"gen9vgc2023series2-1630_move.json\")\n\n# extract the Items data and sort by frequency\nitems <- data.frame(data$Items, stringsAsFactors = FALSE)\nitems <- items[order(-as.numeric(gsub(\"%\", \"\", items$Freq))),]\n\n# select the top 5 items\ntop_items <- head(items, 5)\n\n# create a list of ggplot objects for each item\nitem_plots <- lapply(seq_along(top_items$Item), function(i) {\n  # extract the item name and frequency\n  item <- top_items$Item[i]\n  freq <- top_items$Freq[i]\n  \n  # create a data frame for the current item\n  item_data <- data.frame(Frequency = c(freq, \"Other\"), Count = c(freq, 100 - freq))\n  \n  # create a pie chart for the item\n  p <- ggplot(item_data, aes(x = \"\", y = Count, fill = Frequency)) +\n    geom_bar(stat = \"identity\", width = 1, color = \"white\") +\n    coord_polar(\"y\", start = 0) +\n    ggtitle(item) +\n    theme_void() +\n    theme(legend.position = \"none\")\n  \n  # return the plot object\n  return(p)\n})\n\n# arrange the plots in a grid\ngrid.arrange(grobs = item_plots, ncol = 2)\n```\n:::\n\n::: callout-note\n\\> # arrange the plots in a grid\n\\> grid.arrange(grobs = item_plots, ncol = 2)\nError in unit(rep(1, nrow), \"null\") : \n  'x' and 'units' must have length > 0\n\nI would like to plot the item distributions but ended up with this error message.\n\n::: \n\n\n\n<!-- # Visualization Ideas -->\n<!-- Plot the pokemon in a network visualization: using sizes to amplify the high ranked pm, and the links for their teammates, checkers and counters. Hopefully highlight the teammates interactively when user picks some pms. -->\n\n<!-- Or I will generate an example by pretending to be a user to create a pokemon team from scratch using the visualization. -->\n\n<!-- The purpose of these visualization is to act as a pokemon consult. It will tell you the often used pokemon, and their teammates. -->\n\n<!-- After you choose the team, using visualization to show the potential foes for each pokemon in the team. And for the most dangerous foe, suggest the best counters. -->\n\n<!-- Plot the skills for select pokemons using stacked graph. -->\n\n<!-- Plot the tendencies for the select pokemons in recent years. -->\n\n# Summary\n\nThis blog discusses the popular online community of competitive Pokémon players, Smogon, and its battle simulator, Pokémon Showdown. The blog focuses on the development of effective visualizations using the R package igraph and ggplot2 for the comprehensive datasets available in the Smogon databases. Specifically, the blog presents codes for creating a network visualization of the top 20 Pokémon and their teammates and a stacked bar chart of item frequencies for a specific Pokémon, \"Flutter Mane.\" The visualizations provide insights and suggestions for building a successful Pokémon battle team and help identify patterns in the data that may be difficult to see in a table or spreadsheet format. \n\nOverall, the blog aims to enhance the user's understanding of the data by presenting it in a visually engaging format to facilitate an improved decision-making process and increase the success rate of the user's Pokémon battle team.\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}